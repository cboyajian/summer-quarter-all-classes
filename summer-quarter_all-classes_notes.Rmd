---
title: "Notes and Code from Summer Quarter (all classes)"
author: "Clarissa Boyajian"
date: "12/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(deSolve)
```

# EDS 212: Essential Math for Environmental Data Science

### Logs and exponents in R
Some examples of using the `log()` function and `exp()` **function** in R
```{r}
# Examples of logarithms
log(4)

# Example of exponents
exp(5)

# A test of log()
log(exp(1))
```

### Creating sequences of values
```{r}
# A sequence from 1 to 20, by increments of 1
ex_1_212.1 <- seq(from = 1, to = 20, by = 1)

# Vector from 0 to 40 by increments of 0.2
ex_2_212.1 <- seq(from = 0, to = 40, by = 0.2)

# Vector from 1 to 5000 by increments of 10
ex_3_212.1 <- seq(from = 1, to = 5000, by = 10)
```

### Create a function for logistic growth
Given the carrying capacity, initial population, growth rate, and time, use the logistic growth model to estimate the population at that time.
```{r}
pop_logistic <- function(capacity, init_pop, rate, time_yr) {
  capacity / (1 + ((capacity - init_pop) / init_pop) * exp(-rate * time_yr))
}
  
pop_logistic(capacity = 2580, init_pop = 230, rate = 0.32, time_yr = 2.4)
```

### Try finding population over a sequence of times
```{r}
# Create a vector of times from 0 to 20 by increments of 0.5
time_vec <- seq(from = 0, to = 45, by = 0.25)
```

Now let's estimate the population over that range of times, given capacity = 2580, initial population = 230, rate = 0.32
```{r}
chipmunk_pop <- pop_logistic(capacity = 2580, init_pop = 230, rate = 0.32, time_yr = time_vec)
```

### Create a data frame and plot chipmunk population over time
```{r}
chipmunk_df <- data.frame(time_vec, chipmunk_pop)

ggplot(data = chipmunk_df, aes(x = time_vec, y = chipmunk_pop)) +
  geom_point() + 
  labs(x = "Time (years)", 
       y = "Chipmunk Population (individuals)",
       title = "Inyo National Forest Chipmunks",
       subtitle = "Yay Chipmunks")
```

### Creating functions
```{r}
G <- function(t, z) {
  3.1 * ((t-4.2) ^ 2) + 0.06*z
}

G(t = 1, z = 2.5)


P <- function(initial, rate, time) {
  initial*exp(rate*time)
}

P(initial = 2500, rate = 0.046, time = 4)
```

### End of Day 1 Practice
Make function to calculate fish weight from a, L, and b, calculate weights for one species, create table (sequence) of lengths and weights, plot lenght vs. weight
```{r 212 day 1}
# Create fish weight function
W <- function(a, L, b) {
  a * L^b}

# Milkfish weights
W(a = 0.0905, b = 2.52, L = 60)

# Giant trevally weights
W(a = 0.0353, b = 3.05, L = 60)

# Great barracuda weights
W(a = 0.0181, b = 3.27, L = 60)

# Create df sequence of size ranges from 0-200 by 1 cm
fish_length <- seq(from = 0, to = 200, by = 1)

barracuda_weight <- W(a = 0.0181, b = 3.27, L = fish_length)

# Bind lengths and estimate barracuda lengths in one df
barrracuda_df <- data.frame(fish_length, barracuda_weight)

# Create ggplot graph of lenghts vs. weights
ggplot(data = barrracuda_df, aes(x = fish_length, y = barracuda_weight)) + 
  geom_point() +
  labs(x = "Barracuda length (cm)",
       y = "Barracuda weight (g)",
       title = "Comparing Great Barracudas")
```


## Derivatives in R

### First order univariate derivatives
```{r}
fx <- expression(x^2)

df_dx <- D(expr = fx, name = 'x')
x <- 3

eval(expr = df_dx)
```

```{r}
Pa <- expression(2 * (3 * a + 2)^4 - 5)

dP_da <- D(expr = Pa, name = 'a')
a <- 1.2

eval(expr = dP_da)
```

```{r}
gt <- expression((-4) / (t^2 +1)^3)

dg_dt <- D(expr = gt, name ='t')
t <- 0

eval (expr = dg_dt)
```

### Higher order univariate derivatives
```{r}
Gz <- expression(4.6 - 1.9 * z^3)

dG_dz <- D(expr = Gz, name = 'z')

d2G_dz2 <- D(expr = dG_dz, name = 'z')

d2G_dz2
```

### Partial derivatives
```{r}
h_xyz <- expression(2 * x^2 * y - 3 * x + 1 + 4 * z^4 * x)

dh_dx <- D(expr = h_xyz, name = 'x')
dh_dy <- D(expr = h_xyz, name = 'y')
dh_dz <- D(expr = h_xyz, name = 'z')

dh_dx
dh_dy
dh_dz
```

## Make some plots
```{r}
eq <- function(x) {
  (2.4 * exp(-0.05 * x)) * sin(x)
}

# one method
ggplot(data = NULL) +
  stat_function(fun = eq) +
  xlim(min = -0.5, max = 0.5)

# different method
ggplot(data = data.frame(x = c(-0.5, 0.5)), aes(x = x)) +
  stat_function(fun = eq)
```

```{r}
ggplot(data = penguins, aes(x = bill_depth_mm, y = bill_length_mm)) + 
  geom_point(aes(color = species)) +
  scale_color_manual(values = c("cyan", "purple", "red"))
```

```{r}
ggplot(data = penguins, aes(x = flipper_length_mm, y = species)) +
  geom_jitter() +
  labs(x = 'Flipper Length (mm)', y = 'Penguin Species',
  title= 'Flipper Length Compared to Species')
```


## Day 2 Practice: Derivatives in R
```{r}
fx <- expression(x^2)

df_dx <- D(expr = fx, name = 'x')
df_dx

# Evaluate the slope of f(x) at x = 831
x <- seq(from = -10, to = 10, by = 0.5)
eval(expr = df_dx)
```

```{r}
gt <- expression(3 * t^2 - 4 * cos(t)) 

dg_dt <- D(expr = gt, name = 't')
dg_dt
```

```{r}
# Practice making derivatives
hx <- expression(exp(2 * x^3 - 4 * x^10) - 4 * x - 4)

dh_dx <- D(expr = hx, name = 'x')
dh_dx

x <- 10
eval(expr = dh_dx)
```

## Day 2 Practice: 
Plot a function in `ggplot2`
```{r}
eq <- function(x) {
  3 * x^2 + 4
}

# Use stat_function()
ggplot(data = data.frame(x = c(1, 100)), aes(x = x)) + 
  stat_function(fun = eq)

```

### Practice:
Plot $f(x)=2.4-5x^3+2.1x^2$
Over range of -50 to +50
```{r}
p_eq <- function(x) {
  2.4 - 5 * x^3 + 2.1 * x^2
}
# two examples above of how to create `ggplot`
ggplot(data = data.frame(x = c(-50, 50)), aes(x = x)) +
  stat_function(fun = p_eq)

ggplot(data = NULL) + 
  stat_function(fun = p_eq) +
  xlim(min = -50, max = 50)
```

### Practice: `penguins` body mass and flipper lenghts
Basic ggplot scatterplot of body mass (y) and flipper length (x)
```{r}
ggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point()
# positively correlated, linear slope, notice the x-axis doesn't start at 0, homosedastic (spread of data around model is pretty equal, look for clusters/patterns/etc.)
```

```{r}
ggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point(aes(color = species)) + 
  scale_color_manual(values = c("cyan", "purple", "red")) +
  labs(x = "Flipper Length (mm)", 
       y = "Body Mass (g)", 
       title = "Palmer Penguins Size Measurements", 
       caption = "Data Collected by KB Gorman et al. at Palmer Station", 
       color = "Species")
# updating anything in `ggplot` based on variable has to be within aes()
# update color using scale - google color names to know what R already knows, or can use color code names
```

```{r}
ggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point(aes(color = species)) + 
  scale_color_manual(values = c("cyan", "purple", "red")) +
  labs(x = "Flipper Length (mm)", 
       y = "Body Mass (g)", 
       title = "Palmer Penguins Size Measurements", 
       caption = "Data Collected by KB Gorman et al. at Palmer Station", 
       color = "Species") +
  facet_wrap(~island) +
  theme_light()
# split out into three graphs by using `facet_wrap`
# change theme (Google to get lots of options) using `theme`
```

### Practice: Higher Order Derivative
```{r}
gt <- expression(2.2 + 3.1 * t - 5.6 * t^4)

dg_dt <- D(expr = gt, 't')
dg_dt
```

```{r}
d2g_dt2 <- D(expr = dg_dt, 't')
d2g_dt2
```

### Practice: Partial derivatives
```{r}
f_xyz <- expression(2*x*y - 3*(x^2)*(z^3))

df_dx <- D(expr = f_xyz, 'x')
df_dy <- D(expr = f_xyz, 'y')
df_dz <- D(expr = f_xyz, 'z')

df_dx
df_dy
df_dz
```


## Practice: day 3

### Set up: define parameters
```{r}
### Specify parameters

## Proportion in each compartment: Susceptible 0.999999, Infected 0.000001, Recovered 0 (these are directly from the example linked above)
init <- c(S = 1-1e-6, I = 1e-6, R = 0.0)

## beta: infection parameter; gamma: recovery parameter
parameters <- c(beta = 100, gamma = 0.261)

## Time frame
times <- seq(0, 100, by = 0.5)
```

### Create the function with the differential equations:
```{r}
## Build the function with all 
sir <- function(time, state, parameters) {

  with(as.list(c(state, parameters)), {

    dS <- -beta * S * I
    dI <-  beta * S * I - gamma * I
    dR <-  gamma * I
    
    return(list(c(dS, dI, dR)))
  })
}
```

### Approximate the solution using `deSolve::ode()`:
```{r}
## Solve using `deSolve::ode()`
approximation <- ode(y = init, times = times, func = sir, parms = parameters)

## Get output into a data frame
approx_df <- as.data.frame(approximation)

## Pivot longer so R will do the work for us: 
approx_long <- approx_df %>% 
  pivot_longer(cols = S:R, names_to = "population", values_to = "proportion")

## Plot
ggplot(data = approx_long, aes(x = time, y = proportion)) +
  geom_line(aes(color = population))
```


## Vectors

```{r}
# Create vectors
vec_a <- c(4, 5)

vec_b <- c(-3, 10)
```

### Vecrtor addition
```{r}
vec_c <- vec_a + vec_b
```

### Vector subtraction
```{r}
vec_d <- vec_b - vec_a
```

### Vector scalor multiplier:
```{r}
vec_e <- 4 * vec_b
```

### Dot product
```{r}
# NOT correct attempt at dot product
vec_a * vec_b

# put % around the * to tell R to do dot product rather than just multiplying the vectors
vec_a %*% vec_b
```





# EDS 221: Scientific Programming Essentials










